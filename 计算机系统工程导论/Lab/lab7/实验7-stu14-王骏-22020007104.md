# 《计算机系统工程导论》实验报告

实验名称：计算机系统安全

成绩评定：

姓名：王骏

学号：220 2000 7104

专业年级： 2022级 计算机科学与技术

## *1. 实验目的*

1. 掌握数据安全和防御的基本操作；
2. 掌握缓冲区溢出攻击和防护的基本技术；
3. 理解如何利用安全技术，设计实现更安全的系统。

## *2. 实验过程与习题*

### 实验内容1：分组密码算法（1）

问题：

- iv有什么用处？

  iv（初始向量）确保相同明文加密后产生不同密文，防止模式分析攻击。在CBC模式中，IV与第一块明文异或，消除明文固定模式。

- 使用了什么加密算法？

  使用AES（Advanced Encryption Standard）对称加密算法，密钥长度256位。

- 使用了什么工作模式？这种工作模式有什么优缺点？

  1. **模式**：CBC（Cipher Block Chaining）
  2. **优点**：
     - 相同明文生成不同密文（依赖iv）
     - 支持并行解密
  3. **缺点**：
     - 加密无法并行（依赖前一块密文）
     - 错误传播（单个密文块损坏影响后续两块解密）



### 实验内容1：分组密码算法（2）

问题：

- 出现了什么错误？为什么？

  AES要求明文长度为分组长度的整数倍（16字节）。消息`b"hello ouc cser!"`仅15字节，需填充。



问题：

- 从两次的密文对比来看，有多少个Base64字符出现了变化？这说明加
  密算法应该有什么样的性质？

  修改1个明文字符（如`h→H`），密文所有Base64字符均变化（因CBC模式雪崩效应）。
  **应该有的性质**：加密算法需具备**扩散性**（输入微小变化导致输出巨大变化）。



### 实验内容1：分组密码算法（3）

**如图1：**

问题：

- 对比两次解密结果，思考其体现出的算法性质

  修改1个Base64字符（对应6位密文）：

  - 错误块解密为乱码（因AES解密依赖完整块）
  - 下一块相同偏移位置解密错误（CBC错误传播）
    **性质**：密文需**完整性保护**（如MAC），否则传输错误破坏数据可用性。

附加操作（有时间可进行）

- 尝试不同的工作模式进行加密
- 尝试不同的密码算法进行加密



### 实验内容2：序列加密算法

**如图2：**

问题:

- ChaCha是个什么样的算法，其安全性如何？

  **ChaCha算法**

  - 流密码，基于置换-扩散结构，256位密钥+64位nonce
  - 安全性：可抵御时序攻击，IETF标准化（RFC 8439），性能优于AES-CTR

- 为什么本次操作不需要进行填充？

  流密码逐字节加密，无分块长度限制。



### 实验内容3：公钥密码算法（1）

问题：

- 2048的含义是什么？如果换成其他数字会怎么样？

  RSA模数长度（比特），决定安全强度。

  - `2048`：当前标准（等效112位安全）
  - 改小（如1024）：易被破解
  - 改大（如4096）：计算开销剧增

- 为什么第二级的模块名叫做hazmat？

  提供底层密码原语（如手动填充/密钥管理），误用易引发漏洞，警示开发者谨慎使用。



### 实验内容3：公钥密码算法（2）

**如图3：**

问题：

- 两次加密的结果是否相同？为什么？

  结果不同（即使相同明文）。
  **原因**：OAEP填充引入随机盐（RSA-OAEP非确定性加密）。

- 如果设计的加密算法未考虑填充，会有什么问题？

  相同明文→相同密文（泄露模式）

  易受选择明文攻击（如Bleichenbacher攻击）

  

### 实验内容3：公钥密码算法（3）

问题:

- . 密码学中的hash函数应具有什么性质？

1. 抗原像性（单向性）
2. 抗第二原像性（弱抗碰撞）
3. 抗碰撞性（强抗碰撞）
4. 雪崩效应（输入微变→输出剧变）
5. 定长输出



### 实验内容3：公钥密码算法（4）

问题:

- 验证签名的函数，是如何返回验证成功或失败的消息给调用者的？为什么？
  1. 成功：静默返回（无输出）
  2. 失败：抛出异常（如`InvalidSignature`）
     **设计原因**：避免攻击者通过错误信息侧信道推断密钥信息。

### 实验内容4：缓冲区溢出防护技术

4-1 阅读CTF-WIKI上的ROP示例：

问题

- 用5-10句话简略说明ROP的基本原理

  利用程序中现有指令片段（gadgets），以`ret`指令串联执行链。步骤：

  1. 栈溢出控制返回地址
  2. 将多个gadgets地址压入栈
  3. 每个`ret`跳转至下一gadget
  4. 组合实现恶意逻辑

4-2 GCC中的安全防护机制

### ① canary保护

如图4：

问题

- . Canary一词的来源是什么？借此解释Canary保护的原理

1. **词源**：矿洞金丝雀（预警危险气体）
2. **原理**：函数栈帧插入随机值（canary），返回前校验。若被覆盖（溢出），触发`__stack_chk_fail`终止进程。

### ②Fortify保护

问题

- . 当检测到溢出时，程序的行为有何变化？

  **检测溢出行为**：替换危险函数（如`strcpy→strncpy`），编译/运行时检查长度。溢出时终止进程并输出错误（如`buffer overflow detected`）。

### ③NX（DEP）

问题

. 如何查看内存页的各项权限？

- **查看权限**：`cat /proc/[pid]/maps`（权限标志：`r`读/`w`写/`x`执行）

. 攻击者如何绕过NX防御？给出简单的步骤说明

- **绕过步骤**：
  1. 泄露内存地址（如GOT表）
  2. ROP链调用`mprotect(PROT_EXEC)`
  3. 将shellcode所在页改为可执行



### ④PIE(ASLR)

如图5：

问题

. PIE和PIC的区别？

- PIE：主程序代码地址随机化
- PIC：共享库地址随机化（通过GOT/PLT延迟绑定）

. 如何查看程序的虚拟地址，如何体现地址随机化？

- ```python
  for i in {1..3}; do ldd ./test | grep libc; done  # 观察libc地址变化
  ```

  



### ⑤RELRO保护

问题

. 什么是GOT表？如何查看GOT表权限？

- **GOT表**：全局偏移表，存储外部函数实际地址（动态链接）。

- ```python
  readelf -S test | grep .got.plt  # Full RELRO时该段为只读（REA）
  ```

  



### 实验内容5：进程安全防护技术

问题：

描述该技术的基本原理和简要流程，你认为可以如何改进它？

- **LoadLord原理**
  1. **动态加载**：将代码段（如gadgets）按需加载到随机地址
  2. **密钥绑定**：用进程唯一密钥加密代码指针
  3. **运行时解密**：执行前实时解密指针（攻击者无法预测地址）
- **改进方向**：
  - 硬件加速（如Intel SGX）降低解密开销
  - 自适应机制（按威胁等级调整随机化频率）

## *3. 遇到的问题及解决方法*

#### 问题1：AES加密时出现ValueError: Invalid padding bytes

- **场景**：在实验内容1的分组解密环节，修改密文后解密时程序崩溃

- **原因**：CBC模式中单个字节修改破坏了PKCS#7填充结构

- **解决**：

  1. 使用`try-except`捕获异常

  2. 添加填充验证逻辑：

     ```python
     unpadder = padding.PKCS7(128).unpadder()
     try:
         decrypted = unpadder.update(decrypted) + unpadder.finalize()
     except ValueError:
         print("填充验证失败：可能传输错误或遭篡改")
     ```



#### 问题2：RSA-OAEP加密时抛出Encryption failed

- **场景**：加密较长的教学大纲文本（超过200字节）

- **原因**：2048位RSA最多加密245字节（OAEP填充占用）

- **解决**：

  1. 改用对称加密传输数据

  2. 使用RSA加密对称密钥

  3. 调整：

     ```
     # 生成会话密钥
     session_key = os.urandom(32)
     # 用RSA加密会话密钥
     enc_key = pub_key.encrypt(session_key, pad)
     # 用AES加密实际数据
     cipher = Cipher(algorithms.AES(session_key), modes.CBC(iv))
     ```

#### 问题3：ChaCha20解密得到乱码

- **场景**：网络传输场景下解密失败

- **原因**：nonce重用导致密钥流重复

- **解决**：

  1. 严格保证每个会话使用唯一nonce

  2. 添加认证标签（如Poly1305）

  3. 改用AEAD模式：

     ```
     from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305
     chacha = ChaCha20Poly1305(key)
     ctxt = chacha.encrypt(nonce, b"hello ouc cser!", b"")
     ```

## *4. 课后实验与思考（选做）*

## *5. 实验总结*

本次实验从理论到实践全面了解了数据安全的核心技术。通过亲手实现AES、RSA等加密算法，直观感受到：

1. 一个字节的填充错误就能导致整个系统不可用；
2. Canary+NX+ASLR的组合，单一防护很容易被绕过；
3. 修改明文的1个字符竟会让整个密文面目全非（雪崩效应）

## *附：实验数据与记录*

见docx附件