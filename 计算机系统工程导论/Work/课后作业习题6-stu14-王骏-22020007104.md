

# 课后作业习题6

姓名：王骏

学号：22020007104



**作业要求**：认真阅读题目完成作答，并进行简要分析。

Keys-R-Us已与你签约，要求你实现一个内存中的键-值事务存储，命名为KeyDB。KeyDB提供了一个哈希表接口，用于存储键-值对，并检索之前与键关联的值。

你决定使用锁来提供隔离。锁Lk是针对键k的锁，对应于KeyDB[k]。单个事务可以读取或写入多个KeyDB。你的目标是为所有使用KeyDB的事务实现正确的隔离。事务可能会中止。在对KeyDB[k]进行第一次读取或写入之前，会获取锁Lk，在对KeyDB[k]的最后一次访问之后，会释放锁Lk。

 

### 问题1：对于以下每个锁的相关规则，这个规则对始终保证任何一组并发事务之间正确的隔离，是必要的、充分的，还是既不必要也不充分？

每个所需锁的获取操作必须在事务开始后且在第一个释放操作之前发生，在事务完成或中止之前可以在最后一个读取或写入相应数据之后的任何时间释放锁。

A. 在事务开始后且在第一个读取或写入KeyDB[k]之前必须获取锁Lk，在最后一个读取或写入KeyDB[k]之后但在事务结束之前必须释放锁Lk。

**既不必要也不充分**

**分析：**

- **不充分**：这个规则允许在事务执行过程中释放锁，可能导致脏读、不可重复读等隔离性问题
- **不必要**：可以有更灵活的锁获取时机，不一定要在第一次访问前就获取所有锁

B. 每个所需锁的获取操作必须在事务开始后且在任何其他操作之前发生，如果线程修改了相应的数据项，则在事务完成或中止之前不能释放锁。

**既不必要也不充分**

**分析：**

- **不充分**：只对修改的数据项持锁到事务结束，但对只读的数据项可能过早释放锁，仍可能出现隔离性问题
- **不必要**：不需要在事务开始时就获取所有锁，可以按需获取

C. 每个所需锁的获取操作必须在事务开始后且在第一个释放操作之前发生，如果线程修改了相应的数据项，则在事务完成或中止之前不能释放锁。

**既不必要也不充分**

**分析：**

- **不充分**：类似于B，只保证修改数据的锁持有到事务结束，读锁可能过早释放
- **不必要**：获取时机过于严格

D. 所有获取多个锁的线程必须按照相同的顺序获取锁，不能在事务完成或中止之前之前释放锁。

 **充分但不必要**

**分析：**

- **充分**：按序获取锁避免死锁，持锁到事务结束保证隔离性
- **不必要**：存在其他方式也能保证正确的隔离





### 问题2：确定以下每个锁的相关规则是否可以避免或可能（随着时间无限接近1的可能性）消除任何一组并发事务之间的永久死锁。

A. 每个所需锁的获取操作必须在事务开始后且在任何其他操作之前发生，且在事务完成或中止之前不能释放锁。

**可能消除死锁**

**分析：** 如果事务能预先知道需要的所有锁并一次性获取，可以避免死锁。但实际中很难预先确定所有需要的锁。



B. 每个所需锁的获取操作必须在事务开始后且在第一个释放操作之前发生，且在事务完成或中止之前不能释放锁。

**无法避免死锁**

**分析：** 这本质上是两阶段锁协议，虽然保证隔离性，但无法避免死锁。多个事务可能以不同顺序获取锁，形成循环等待。



C. 所有获取多个锁的线程必须按相同的顺序获取锁。

**可以避免死锁**

**分析：** 经典的锁排序策略。如果所有事务都按相同顺序获取锁，就不会形成循环等待，从而避免死锁。



D. 当事务开始时，设置一个定时器，其时间长于预计的事务执行时间。如果定时器超时，则中止当前事务，并通过随机指数退避算法选择一个新的时间值，然后再次尝试执行事务。

**可能消除死锁**

**分析：** 超时机制可以打破死锁循环，随机退避减少重复冲突的概率。虽然不能完全避免死锁的发生，但能及时检测和恢复